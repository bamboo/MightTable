{
  "name": "meta-script",
  "version": "0.0.30",
  "author": {
    "name": "Massimiliano Mantione",
    "email": "massimiliano.mantione@gmail.com"
  },
  "description": "A language with a compiler that targets Javascript.",
  "repository": {
    "type": "git",
    "url": "https://github.com/massimiliano-mantione/metascript.git"
  },
  "main": "./lib/meta",
  "bin": {
    "mjs": "./bin/mjs"
  },
  "dependencies": {
    "escodegen": ">=0.0.28",
    "require-like": "^0.1.2",
    "source-map-support": "*"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "~2.0.2"
  },
  "scripts": {
    "prepublish": "node ./lib/build-macros.js",
    "pretest": "node ./lib/build-macros.js",
    "test": "mocha"
  },
  "jshintConfig": {
    "globals": {},
    "browser": false,
    "node": true,
    "strict": false,
    "white": true,
    "smarttabs": true,
    "undef": true,
    "unused": true,
    "onecase": true,
    "lastsemic": true,
    "newcap": false,
    "maxlen": 100,
    "indent": 2,
    "predef": [
      "describe",
      "it",
      "before",
      "beforeEach",
      "after",
      "afterEach"
    ]
  },
  "keywords": [
    "compiler",
    "language",
    "metaprogramming"
  ],
  "license": "MIT",
  "engines": {
    "node": ">=0.8"
  },
  "readme": "Metascript\n==========\n\nThis is yet another programming language that compiles to Javascript.\nThe main goal is to have a language that can have a readable syntax, and at the same time allow lisp-style metaprogramming (macros that can manipulate the AST).\nAnother goal is to have a type system, for optionally performing static type checking (with type inference).\n\n\nProject Status\n--------------\n\nThere a library (npm module) implementing the compiler, with a script to invoke it on from the command line (as 'mjs <input.mjs>').\nEverything described below already works, and the compiler generates source maps by default.\n\n\nTo run the tests, do the following:\n- clone the repository at \"https://github.com/massimiliano-mantione/metascript\", then\n- run \"npm install\" and \"npm test\".\n\nOtherwise, if you only want to try the compiler, just do \"npm install meta-script\" and have fun running the 'mjs' script. But I'd still suggest to have a look at the tests written in Metascript to see some code samples.\n\nThere is [Gulp](http://gulpjs.com/) integration [here](http://github.com/bamboo/gulp-mjs), and a [Lighttable](http://www.lighttable.com/) plugin [here](http://github.com/bamboo/MightTable), thanks to [Bamboo](http://bamboo.github.io/).\n\nThere is a Google group (metascript@googlegroups.com), it is still empty but discussion about Metascript is supposed to happen there.\n\nHave a look at the TODO list at the end to see what's coming next.\n\n\nA Quick Taste of the Language\n-----------------------------\n\nOur favorite first statement:\n\n```\nconsole.log 'Hello, Metascript!'\n```\n\nAn 'if' expression:\n\n```\nrequire 'should'\n(if true 1 else 2).should.equal 1\n```\n\nA concise definition of a function that returns the factorial of its argument (note that the syntax looks like a tail recursive definition but it is compiled into a plain loop):\n\n```\nvar f = (x) ->\n  loop (var r = 1, x)\n    if (x > 0)\n      next! (r * x, x - 1)\n    else\n      give! r\nf(1).should.equal(1)\nf(2).should.equal(2)\nf(3).should.equal(6)\nf(6).should.equal(6 * 5 * 4 * 3 * 2)\n```\n\nMetascript supports real macros! Here is how we could define an '@' operator that behaves like the Coffeescript one:\n\n```\nmeta\n  macro \"@\"\n    predecence: KEY\n    expand: do\n      var code = \\<- this.arg\n      code.replaceTag('arg', expr.argAt(0))\n      give! code\nvar obj = {\n  a: 1\n  b: 2\n  m: () -> (@a + @b)\n}\nobj.m().should.equal(3)\n```\n\nMore generally, the core Metascript language is relatively small and every advanced construct can be implemented with macros.\n\n\nMotivation\n---------------------\n\nThe fact that Javascript  is a \"problematic\" language is well known.\nSomebody takes it as it is, while others have implemented transpilers that translate arguably better languages into Javascript.\n\nI have examined several of those projects but none of them is ideal for me.\n[Coffeescript](http://coffeescript.org/) is really nice, probably the only issue I have with it is that its syntax is a bit irregular. Other than that I like how it encourages a more functional coding style, how it fixes comparison operators and in general the readability of Coffeescript code.\nThen [Typescript](http://www.typescriptlang.org/) adds a type system that can be useful for large projects. However as a language it is still plain Javascript, with all its problems.\nHaving a mix of Coffescript and Typescript would be nice but they cannot be \"merged\": one has to choose.\nAnd finally, the thing I am missing the most is language extensibility, in the form of [Metaprogramming](http://en.wikipedia.org/wiki/Metaprogramming) as you can do with Lisp and Scheme macros. There is a nice language, [Lispyscript](http://lispyscript.com/), that tries to bring this to Javascript, but it is a Lisp, with its syntax full of parenthesis which for me is not ideal...\n\nSeveral other languages have inspired me in various ways:\n - [Boo](http://boo.codehaus.org/) is simply amazing, but it is designed with a CLI runtime environment in mind and not a Javascript one.\n - [Roy](http://roy.brianmckenna.org/) is an interesting attempt at providing a [Haskell](http://www.haskell.org/haskellwiki/Haskell)-like language.\n - [Clojurescript](https://github.com/clojure/clojurescript) also provides metaprogramming and is _really_ nice, with the issue that it still has a Lisp-plagued syntax and that it feels \"closer\" to the [Clojure](http://clojure.org/) ecosystem than to the Javascript one...\n\nIn the end I decided that none of them fits my bill completely, and I implemented Metascript.\n\nThe Metascript Language\n------------\n\nThe goal is to have a language that can have a readable syntax (inspired by Coffeescript), and at the same time allow lisp-style metaprogramming (macros that can manipulate the AST).\n\nLisp-like languages have a \"clean\" syntax because, in a sense, they have no syntax at all: they explicitly use parenthesis everywhere to express the grouping of expressions.\nMetascript uses a combination of parenthesis, indentation and infix operators so that the syntax is more \"comfortable\" and similar to the one used in mainstream programming languages.\n\n### Expressions\n\nSimple expressions are intuitive to read:\n\n```\n(1 + 2 * 3).should.equal 7\n```\n\nIn Metascript there is no real distinction between expression and statement: almost every construct is an expression.\nParticularly, 'if', 'loop', 'do' (_do_ is the equivalent of code blocks) and 'try' are expressions that produce values and can be freely nested inside other expressions:\n\n```\nvar mood = if happy ':-)' else ':-('\n```\n\nIn general this reduces the need for temporary variables and encourages (or at least allows) a more 'functional' coding style.\n\n### Grouping\n\nOf course more complex expressions will need some form of grouping.\nIn general expressions can be grouped for two reasons:\n- to evaluate all of them and pass the results to another expression (like in the case of the arguments of a function call), or\n- simply to evaluate all of them sequentially discarding the values (like in a code block).\nIn both cases the developer can choose to group expression with parenthesis or indentation.\nWhen parenthesis are used the subexpressions must be separated by commas ',':\n\n```\nfunctionCall(1, 2, 3)\n```\n\nwhile when indentation is used the separators are the line breaks:\n```\nfunctionCall\n  1\n  2\n  3\n```\n\nThe idea is that indentation levels add nested parenthesized expressions to the parent expression. Every newline can do one of three things:\n- be _more_ indented: it adds a nested subexpressions as an operand of the current one,\n- be _less_ indented: it closes all the expressions (or blocks) that are more indented and resumes adding operands to the current level\n- be at the _same_ level as the previous line: it adds another subexpression to the current block\nNote that the indentation rules are simple and they do not depend on operator precedence at all. Inside each line of code, however, standard Javascript operator precedence rules are applied.\n\nSince with these rules the semicolon delimiter ';' is totally useless (commas work just fine) in Metascript it starts a comment:\n\n```\n; Here is a comment!\nconsole log 'The above line is a comment.'\n```\n\nwhich means that ending lines with semicolons is harmless but useless :-)\n\n### Control Flow Expressions\n\n#### if\n\nAn _if_ expression works mostly as expected.\nIt can have only one consequent, like here:\n\n```\nif problem\n  console.log error\n```\n\nor it can have an else branch:\n\n```\nif ok\n  activate engine\nelse\n  stop\n```\n\nIf it is complete (it has both a consequent and an else branch) it can be used as a nested expression similarly to the Javascript ternary 'c ? x : y' operator.\n\n#### do\n\nTo understand the need for _do_ blocks we should have a look at tuple assignments first.\nIn Metascript one can write\n\n```\nvar (a, b) = (1, 2)\na.should.equal 1\nb.should.equal 2\n```\n\nand even\n\n```\nvar (a, b) = if true (1, 2) else (3, 4)\na.should.equal 1\nb.should.equal 2\n(a, b) = (b, a)\na.should.equal 2\nb.should.equal 1\n```\n\nIn other words, a sequence of expressions is just that: a sequence of values (or, better, a _tuple_).\n_if_, _do_, _loop_ and all the assignment operators can deal with tuples, and technically every function invocation uses a tuple as arguments.\n\nNow consider the following two _if_ expressions:\n\n```\n; A tuple evaluation\nvar (a, b) = if condition (f 1, f 2) else (f 3, f 4)\n\n; Imperative execution of expressions, discarding their values\nif condition do\n  f 1\n  f 2\nelse do\n  f 3\n  f 4\n```\n\nIt should be clear that in the second one _f_ is invoked discarding its return value, only for its eventual side effects, and the _if_ expression executes one of the two _do_ blocks according to the value of _condition_.\n\nHowever, _do_ expression **can** return a value!\nConsider the following:\n\n```\nvar status =\n  if ok do\n    console.log 'Starting up'\n    engine.power 100\n    give! 'moving'\n  else do\n    console.log 'Stopping'\n    engine.power 0\n    give! 'stopped'\n```\n\nThe meaning should be clear: status will be either 'moving' or 'stopped', the _if_ works like an expression selecting one of the two values, and the two _do_ code blocks execute 'statements' (they evaluate expressions but discard their values) but they also 'return' values so that the _if_ expression can use them.\n\n#### Data flow considerations\n\nThe Metascript compiler performs some basic data flow analysis on the code it processes.\nParticularly, it checks the following:\n- that every assignment has an assignable expression on its left side,\n- that every expression produces the required value (or values),\n- that every variable has been declared in the current scope, and\n- that every variable is not used undefined (this is still unimplemented)\n\nEvery expression is evaluated in a context where a certain number of result values is required. For instance, consider the following assignment:\n\n```\nvar a = b + c\n```\n\nHere the expression _b + c_ needs to produce one result because the assignment requires one value. In the following example, however, the expression needs to produce two values:\n\n```\n(o.x, o.y) = (x + dx, y + dy)\n```\n\nand in fact it is a tuple of length two. And, of course, the following example will cause a compile error:\n\n```\nvar m = (x, y)\n```\n\nThe rules are simple:\n- Assignable expressions are:\n    - variables and function arguments, and\n    - the result of _member_ expressions (either _x.y_ or x[y]).\n- Assignment operators count the number of expressions on their left, check that they are assignable, and require an equal number of values on the right.\n- _if_ and _do_ expressions must produce the number of results required from their context\n    - _if_ expressions produce results by simply evaluating them\n    - since _do_ expressions already evaluate a sequence of expressions, if they must produce a value they can be terminated in two ways:\n      - with a _give!_ statement that specifies the result of the _do_, or\n      - their last expression is assumed to be the result of the _do_.\n- Function invocations are like a binary operator that requires one value on the left (the callee) and an argument on the right, which can be a tuple (the arguments).\n- Every other operator requires exactly one value for each operand.\n\nIn Metascript it is necessary to specify the _do_ keyword every time a tuple is provided in a context where values are required but it must not be evaluated as a tuple. In this case the result of the _do_ expression (which _could_ be a tuple!) must be provided by a _give!_ expression.\nOf course _give!_ expressions can be used inside conditional statements (_if_ branches), in any case when \"evaluated\" they terminate the current _do_ block and provide its result(s).\n\nTo keep the code less verbose I also made the _give!_ at the end of a _do_ optional, assuming that the last expression of the _do_ sequence will be its result (the suggestion came from [Bamboo](http://bamboo.github.io/), the desigmer of [Boo](http://boo.codehaus.org/)). Therefore the above example can also be written like this:\n\n```\nvar status =\n  if ok do\n    console.log 'Starting up'\n    engine.power 100\n    'moving'\n  else do\n    console.log 'Stopping'\n    engine.power 0\n    'stopped'\n```\n\nBut note that Metascript encourages a coding style where side effects are condensed in assignment expressions and _do_ sequences can be avoided: the above code snippet can also be written like this (with almost identical results):\n\n```\nvar (status, message, power) =\n  if ok ('moving', 'Starting up', 100)\n  else ('stopped', 'Stopping', 0)\nconsole.log message\n```\n\n#### loop\n\nMetascript has only one kind of _loop_ expression, and it tries to mimic the syntax of tail recursive invocations (but it generates plain loops in Javascript). Just like in Lisp-like languages, other looping constructs can be defined with macros.\n\nLet's write the 'factorial' computation of a number _x_ that we get from some _input_ function:\n\n```\nvar x = input()\nvar r = loop (r = 1, x)\n  if (x > 0)\n    next! (r * x, x - 1)\n  else\n    give! r\nconsole.log('The factorial of ' + x + ' is ' + r)\n```\n\nA _loop_ expression has two arguments:\n- a tuple of assignable expressions (with optional initializers), and\n- one expression which is the loop body.\nJust like a _do_, it can be terminated with a _give!_ statement which provides the result of the _loop_ expression.\nHowever it also allows the use of a _next!_ statement, which:\n- needs a tuple of values, of the same length of the _loop_ tuple,\n- provides one new value for each element of the _loop_ tuple, and\n- jumps to the beginning of the loop.\nThis final 'jump' performed by _next!_ is what makes _loop_ work like a tail recursive function, and the _loop_ tuple acts like the arguments of this imaginary function.\nThe _next!_ and _give!_ keywords are one of the few Metascript constructs that are not expressions: they cannot \"provide a value\" because they are like jump statements.\n\n_TODO_ Explain better why I choose this as the only looping primitive and how every other loop construct can be implemented as a macro (and there will be a standard library of such macros).\nNote that there are already examples of these macros in the tests.\n\n### Variable declarations\n\nMetascript, like Cofeescript, tries to shield the programmer from subtle errors that can creep into Javascript programs when an undeclared variable is assigned (which causes the creation of a new property in the global object).\n\nHowever in Metascript the rules are different: the programmer must explicitly declare every variable.\nMetascript puts every declaration at the beginning of the local \"Javascript scope\" in the generated code (which means either the beginning of the compilation unit, or the beginning of the current function), but it handles naming resolution like if the language had block scoping.\nMoreover, Metascript does not allow the declaration of a variable with a name already used in the current scope (in this case I mean _block_ scope and not _function_ scope). I made this choice because scoping (and captured variables) are really important in Javascript, and I think that redefined names cause ambiguities reading code and should be avoided. Moreover, with this rule, if one never relies on the value of undefined variables (note, _undefined_, not just _undeclared_!), for all practical purposes Metascript provides variable declarations with local scoping which IMHO is a very desirable thing to have.\nAnd since the data flow analysis performed by the Metascript compiler disallows uses of undefined variables local (this piece of analysis is still unimplemented) using an undefined variable is not possible anyway.\n\n### Function Definitions\n\nFunctions are defined as expressions using the '->' operator (the resulting value must be used or assigned somwehere), with a syntax just like the Cofeescript one:\n\n```\nsquare = (x) -> x * x\ncube = (x) -> square(x) * x\nsquare(2).should.equal 4\ncube(2).should.equal 8\n```\n\nTo remind the grouping syntax, the following definitions do the same thing as the above ones:\n\n```\nsquare = (x) ->\n  x * x\ncube = (x) ->\n  square(x) * x\n```\n\nAbout data flow analysis, the body of a function definition is handled as following:\n- if it is:\n    - a _do_ expression,\n    - an non empty tuple, or\n    - a _return_ expression\n  it is assumed to provide no return value, otherwise\n- the compiler will produce a return statement and will assume that the body expression must produce exactly one value, which will be returned by the function.\nThis way the programmer can always write very concise code but the compiler will anyway be able to perform data flow analysis with no ambiguities.\n\n### _TODO:_ switch, case\n\nTechnically, a _switch_ could be implemented with a sequence of chained _if...else_ expressions, so it could be implemented as a macro.\nThere is one special case where being able to emit a real Javascript _switch_ statement would have a small performance advantage: if the _case_ arguments are all integers, a smart virtual machine can emit a very fast jump table.\n\nMy plan is to implement a _switch_ macro that can be easily extended with various matching patterns in case statements, and eventually handle the \"switch to jump table\" optimization in the code generation of _if_ expressions.\nThis will keep the core language smaller which is important for macros that manipulate the control flow in advanced ways.\n\n### Compound Literal Values\n\nMetascript supports array and object literals exactly like Javascript, and uses roughly the same syntax to define them (_[]_ for arrays and _{}_ for objects).\nThe only difference comes from the fact that indentation rules can be used inside literals, too.\n\nThe trick is the following:\n- If, after an open _[_ or _{_, something is written on the _same_ line, the parser stays in _()_ mode and expects commas as separators for the value elements (or properties).\n- If, on the other hand, a newline is found immediately after the opening of the literal, the following block will be taken as the object content (using newlines as separators and following the indentation rules).\n\nThis is best shown with an example, in which we have two identical definitions:\n\n```\nvar obj1 = {a: 1, b: 2}\nvar obj2 = {\n  a: 1\n  b: 2\n}\n```\n\nI know that Cofeescript allows the programmer to omit _{}_ braces entirely when defining object literals, and I consciously decided to take a different route and make them mandatory. Doing otherwise would have created way too many ambiguities in the parser (and, IMHO, also in reading code). Moreover, it is really easy to write a macro that builds an object literal without requiring braces! (more about this in the _Metaprogramming_ section)\n\n### String Interpolation and \"heredoc\" Strings\n\n_TODO_: please note that this is still not implemented in the parser, I plan to do it soon.\nMetascript does not really provide string interpolation, however it allows to concatenate strings and the results of other expressions very easily.\nThe trick is the following: even with string interpolation, one usually must introduce some kind of \"delimitation character\" in the string to separate the expressions from the string literal (something like \"The distance is ${speed * time} meters\").\nWithout string interpolation, the above string would need to be written with this expression:\n\n```\nvar s = \"The distance is \" + (speed * time) + \"  meters\"\n```\n\nand what is annoying is that the programmer must write both the quotes and the _+_ operators.\nHowever, one can note that the following expression would be illegal\n\n```\nvar s = \"The name is \" name\n```\n\nbecause the parser, finding no operator, would attempt to produce a function call where the callee is the string literal, which makes no sense and would cause a runtime error.\nSince the expression would be illegal it would be nice to use that kind of construct in a useful way.\n\nTherefore Metascript supports an abbreviated form of string concatenation, like this:\n\n```\nvar s1 = \"The distance is \" (speed * time) \"  meters\"\nvar s2 = \"The full name is \" surname \" \" name\n```\n\nwhich for practical purposes works just like string interpolation, and is translated into the following code:\n\n```\nvar s1 = \"The distance is \" + (speed * time) + \"  meters\"\nvar s2 = \"The full name is \" + surname + \" \" + name\n```\n\nAlso having a string that \"calls a tuple\" (another construct that would make no sense) is translated into a repeated concatenation of the string with every element of the tuple, allowing code like this:\n\n```\nvar longString = ''\n  'One string, '\n  'another string, '\n  'one more string...'\nvar interpretedAs '' 'One string, ' 'another string, ' 'one more string...'\nvar whichMeans '' + 'One string, ' + 'another string, ' + 'one more string...'\n```\n\nFinally, Metascript supports \"heredoc\" strings, which start with three consecutive quotes followed by anything (even the empty string) and then a newline, and are closed by a line starting with exactly the same sequence of characters (including the quotes), like this:\n\n```\nvar longString = '''end\nOne line,\nanother line,\none more line...\n'''end\n```\n\nNote that _end_ in the above example can be anything, even the empty string, it is used only to make it easier for the programmer to produce long strings that contain lines that start with exactly three consecutive quotes...\n\nMetaprogramming\n---------------\n\nMetascript supports metaprogramming allowing the developer to write macros that modify the AST at compile time. This makes the language extensible because macros can define new language constructs. It is also practical because new keywords and operators can be added to make code easier to read (and less tedious to write!).\n\nLet's see, as an initial example, how to define an operator that, like Coffescript's _@_, translates into \"_this._\" in the final program:\n\n```\nmeta\n  macro '@'\n    precedence: KEY\n    expand: do\n      var member = expr.argAt(0)\n      var code =\n        if (member.isTag())\n          \\<- this.member\n        else\n          \\<- this[member]\n      code.replaceTag('member', member)\n      give! code\n```\n\nThis macro could be used in the following way:\n```\nvar obj = {\n  a: 1\n  b: 2\n  aaa: 42\n  m1: () -> (@a + @b)\n  m2: (x, y) -> @(x + y)\n}\nobj.m1().should.equal(3)\nobj.m2('a', 'aa').should.equal(42)\n```\n\nIn Metascript the _meta_ keyword introduces metaprogramming statements.\nThe _macro_ statement defines a new macro, and it must be followed by the string that represents the new operator (or keyword), in this case _@_.\nThen a few properties must be specified, with a syntax like the one used in properties in object literals:\n- _arity_ to specify the number of arguments of the operator, it defaults to 'unary', other useful values are 'binary', 'optional' (for as keyword that might or might not have an operand), 'zero', or others that will be documented later.\n- _precedence_ defines the operator precedence (_TODO_: document the precedence table), defaults to 'KEY'.\n- _dependsFrom_ is for keywords that must work together with others to build more complex constructs (like _catch_ is related to _try_, or _else_ is related to _if_).\n- _expand_ is the only mandatory property, it provides the code that implements the macro.\n\nThe macro implementation has two variables in its scope:\n- _expr_ is the root of the AST tree where the macro must be expanded (in the above example _expr_ will be _@a_, _@b_ and then _@(x + y)_).\n- _meta_ is an object that represents the compilation environment (still undocumented, will be useful in complex code generation scenarios, and can be ignored for now).\n\nIn the above example the macro does the following (remember that it runs at _compile_ time, at every use of the defined symbol in the source code):\n- it extracts the argument passed to the _@_ operator (with _expr.argAt(0)_)\n- it checks if it is a \"tag\" (which means an identifier) or not\nNow we must explain what _code quoting_ is.\nIn Metascript the _\\\\->_ operator is the _quote_ operator for parse trees, it is the one that provides the macros new peices of code to put into the final program.\nIn the above example we have two such snippets of code:\n- _this.member_, which makes sense if _member_ is a tag, and\n- _this[member]_, which must be used otherwise.\nThe macro code selects the correct code snippet and assigns it to the _code_ variable.\nNow in the macro code we have assigned two variables:\n- _member_, with the _@_ operand, and\n- _code_, with the code we want to put in the program instead of the _@_ operator.\nBy invoking _code.replaceTag('member', member)_ we replace _member_ (the _@_ operand) with \"member\" in the code snippet. After that, the code snippet is exactly what we want, and it can be returned.\n\nThe Metascript compiler will then replace the _@_ occurrence with the code returned by the _expand_ function in the macro definition.\nThis will make the two method definitions look like this:\n\n```\n  m1: () -> (this.a + this.b)\n  m2: (x, y) -> this[x + y]\n```\n\nOf course this is a very simple macro.\nMore complex ones can accomplish more useful tasks.\nFor instance if we wanted to have a _while_ statement in Metascript. the following macro implements it easily:\n\n```\nmeta\n  macro \"while\"\n    precedence: LOW\n    arity: binaryKeyword\n    expand: do\n      var code = \\<- loop ()\n        if (!(condition))\n          end!\n        else\n          body\n          next! ()\n      code.replaceTag('condition', expr.argAt(0))\n      code.replaceTag('body', expr.argAt(1))\n      give! code\n```\n\nAfter this macro we can write something like this:\n\n```\nvar (c = 1, r = '')\nwhile (c <= 3)\n  r += c\n  c = c + 1\nr.should.equal '123'\n```\n\nand of course the test would pass.\n\nHow the macro works should be obvious: _code_ contains the \"skeleton\" of the code we want to emit, then we replace _condition_ and _body_ with the _while_ expression arguments and we return the resulting piece of code.\n\n\n\nAnother useful macro that can be written is a \"quote code and replace tags\", very useful in writing macros!\nIt can be found in the tests, anyway it works like this:\n\n```\n{\n  tag1: replacement1\n  tag2: replacement2\n  ...\n} \\<-> quotedCode\n```\n\nSo, the _\\\\<->_ operator takes an object literal and a piece of code, and it repeatedly invokes _replaceTag_ on the code, once for every property of the object literal.\nWith this operator the _while_ macro can be written in the following way:\n\n```\nmeta\n  macro \"while\"\n    precedence: LOW\n    arity: binaryKeyword\n    expand: do give!\n      {\n        condition: expr.argAt(0)\n        body: expr.argAt(1)\n      } \\<-> loop ()\n        if (!(condition))\n          end!\n        else\n          body\n          next! ()\n```\n\nwhich is more concise and readable.\n\nThen I should write an _unquote_ macro, which should be used inside quoted code to insert pieces of code that will provide a local replacement (like an \"inline macro\").\nSince it is the opposite of \"quoting\" I would give the macro the _\\\\->_ symbol.\nWith that macro the _while_ definition would become the following:\n\n```\nmeta\n  macro \"while\"\n    precedence: LOW\n    arity: binaryKeyword\n    expand: do give! \\<-\n      loop ()\n        if (! \\-> expr.argAt(0))\n          end!\n        else\n          \\-> expr.argAt(1)\n          next! ()\n```\n\nAnother useful Metascript feature is the ability of producing variables with unique names when expanding macros, without forcing the programmer to explicitly call \"gensym\"-like functions (for those that know Lisp and Scheme, this means that Metascript makes it easy to write [hygienic macros](http://en.wikipedia.org/wiki/Hygienic_macro)).\nTo make use of the feature the programmer needs to use the _\\\\_ operator before identifiers that must be made unique, like this:\n\n```\nvar code = \\<- do\n  var \\condition = f(g)\n  if (\\condition) ...\n```\n\nEvery time a macro containing that quoted code will be expanded, _condition_ will get a unique identifier. Therefore multiple uses of the macro in the same scope will not cause problems with redeclarations of the same variable.\n\nThis introduction only scratches the surface of metaprogramming.\n\nI hope that it at least makes it clear why I kept the core of the Metascript language very small: everybody has his opinions about which constructs a programming language should provide, and I am pretty sure that I cannot make everyone happy. At least in this way everybody can  extend the language as he pleases.\nMoreover, this will make the implementation of \"global\" features easier. For instance, think about the introduction of a type system: since there are only a handful of base language constructs, it is easier to implement type checking for them than how it would be for a language that needs to provide more \"builtin features\" because it cannot be extended.\n\nTODO List\n---------\n\n- Organize the todo list as issues that can be tracked on Github\n- Expand the [Light Table](http://www.lighttable.com/) [plugin](http://github.com/bamboo/MightTable):\n  - at the cursor location, make it possible to inspect:\n    - the AST produced by the parser\n    - the AST after macro expansion\n    - the generated javascript code\n    - the arity of the expression as inferred by the compiler\n  - it would be nice to have a mode where the editor automatically selects the current expression (AST subtree) at the cursor location, and changes it following the cursor movement\n  - integrate the plugin with the nodejs and browser REPL clients so that also Metascript will have a REPL\n  - maybe implement a ternjs-like code analysis to have member autocompletion\n- Write more useful macros\n    - looping ones\n    - generators\n    - array comprehension\n    - destructuring assignments and structure matchers\n    - switch\n    - small useful operators\n    - 'double arrow' functions\n- Implement the trick about string interpolation\n- Settle on an API for a module system for macros (meta-modules!)\n- Document the AST API that can be used inside macros.\n- Implement the type system, and expand the lighttable plugin to provide type-assisted autocompletion.\n- Finish this TODO list :-)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/massimiliano-mantione/metascript/issues"
  },
  "homepage": "https://github.com/massimiliano-mantione/metascript",
  "_id": "meta-script@0.0.30",
  "_shasum": "d4aea06ffc5a96fa474f07183253ff4e5865dd75",
  "_from": "meta-script@0.0.30",
  "_resolved": "https://registry.npmjs.org/meta-script/-/meta-script-0.0.30.tgz"
}
