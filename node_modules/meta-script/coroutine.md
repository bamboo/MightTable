

var splitter = (expr, argsTag, makeResumeCallbackTag) ->
  if (mustSplit)
    {tail: ..., resume: ...}
  else null


runBlock environment:
  argsTag
  currentResultTag
  nextBlockTag
  failBlockTag
  makeResumeCallbackTag



(constrArgs...) ->
  var args = []

  ; put all captured vars here...

  var currentResult = ()
  var nextBlock = 0
  var failBlock = -1
  var failHandler = .... ; Get it from constrArgs
  var runBlock = null;

  var makeResumeCallback = (resumeBlock, argc) ->
    (arg0, arg1) -> do
      args.length = 0
      if (argc > 0)
        args.push arg0
      if (argc > 1)
        args.push = arg1
      if (argc > 2)
        loop (var argIndex = 2)
          if (argIndex < argc)
            args.push(arguments[argIndex + 1])
            next (argIndex + 1)
      }
      loop (var currentBlock = resumeBlock)
        if (currentBlock >= 0)
          currentBlock =
            try
              runBlock currentBlock
            catch e
              if (failBlock >= 0)
                failBlock
              else if failHandler do
                failHandler e
                -1
              else
                throw e
          next(currentBlock)
        else
          args.length = 0
          return currentResult

  var resume = makeResumeCallback((), 0)

  runBlock = (resumeBlock) -> do
    if (resumeBlock == ())
      resumeBlock = nextBlock
    if (resumeBlock == -1)
      nextBlock = 0
      currentResult = resume
      ; cleanup captured vars here
      return -1
    else if (resumeBlock == 0)
      ; block 0 code here
      ; return nextBlock
    else if ...
    else
      ; throw?

  return runBlock


var generatorBuilder = #generator
  ; block 1
  yield 1
  ; block 2
  yield 2

var generator = generatorBuilder()



runBlock = (resumeBlock) -> do
  if (resumeBlock == 1)
    currentResult = 1
    nextBlock = 2
    return -1
  else if (resumeBlock == 2)
    currentResult = 2
    nextBlock = -1
    return -1

{
  _code: .... (runcode)
  next: () ->
    this._code()
  current: currentResult
}



var coroutineBuilder = #generator
  ; block 1
  var c1 = makeChannel()
  var c2 = makeChannel()
  var data = readChannel c1
  ; block 2
  writeChannel <- c1 data

var coroutine = coroutineBuilder()


() ->
  var args = []

  ; put all captured vars here...
  var c1, c2, data

  var runBlock = null;

  var makeResumeCallback = (resumeBlock, argc) ->
    (arg0, arg1) -> do
      args.length = 0
      loop (var argIndex = 0)
        if (argIndex < argc)
          args.push(arguments[argIndex + 1])
          next (argIndex + 1)
      loop (var currentBlock = resumeBlock)
        if (currentBlock >= 0)
          currentBlock =
            try
              runBlock currentBlock
            catch e
              if (failBlock >= 0)
                failBlock
              else if failHandler do
                failHandler e
                -1
              else
                throw e
          next(currentBlock)
        else
          args.length = 0
          return currentResult

  var resume = makeResumeCallback((), 0)

  runBlock = (resumeBlock) -> do
    if (resumeBlock == 1)
      c1 = makeChannel()
      c2 = makeChannel()
      ; var data = readChannel c1
      doAsyncCall(makeResumeCallback(2, 1))
      return -1
    else if (resumeBlock == 2)
      data = args[0]
      currentResult = 2
      nextBlock = -1
      return -1


select
  do
    v1 <: c1
    console.log ...
  do
    v2 <: c2
    console.log ...
  do
    v3 <: c3
    console.log ...


  do
    c1
    c2
    c3
  do
    cleanupSubscriptions
    v1 <: c1
    console.log ...
  do
    cleanupSubscriptions
    v2 <: c2
    console.log ...
  do
    cleanupSubscriptions
    v3 <: c3
    console.log ...

var a
var a, b

var
  a = 1
  b = 2
  c
  d = 4


  (def a) = 1
  (def b) = 2
  (def c)
  (def d) = 1

tag "identifier"
declarationTag
constTag
virtualTag
argument
name

value.prop
