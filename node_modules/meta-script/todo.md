
# How to bring Metascript to a "production-ready" state

## Enhancements to the compiler

### Write the codegen for try-catch-finally

This is trivial but I still need to do it.

### Allow a new kind of token

I'd like to allow identifiers that start (and contain) the '#' symbol as "operators".
Handling them as operators would allow to use them as macro identifiers while still disallowing their use as variables and function arguments, effectively creating a sort of "separated namespace" for macros and directives (see below).

### Allow for "extensions" of an existing macro (or key symbol in general)

The idea is that the user can add another "expand" method to existing macros or symbols, valid for the local scope (which could be the whole file).
It would not be possible to change the symbol arity or precedence, just its "behaviour" as a macro (or even primitive): the new "expand" would be called first, and only if it returns undefined the original expand would be called.

This would allow redefining existing constructs in interesting ways, like:

* array comprehensions
* destructuring assignments
* the "string concatenation" trick could also be implemented as an extension that converts calls...

### Simplify the AST API

Some of the methods should be shorter, or be changed into properties.
Apart from that it is already generic enough to be fully usable, and with the simplification it would be integrated into "looping macros" to be even easier to use.

### Rework the macro directive and create a generic "meta-directive" system

In Metascript we have normal code, and macro definitions.
More generally, macro definitions are "meta-statements" that change the compiler state and not the program.
For instance, defining a macro changes the compiler so that, from now on, it will recognize the macro in expressions (and will later be able to expand it).

I already have several other kinds of "meta statements" in mind, which I would call "directives".
Initially I wanted all of them to be specified under the "meta" keyword (which I could change into "#meta"). However this could be changed as we could have a "directives" symbol table in the compiler, and we should have a "#directive" directive that allows the developer to specify new directives.

This is technically different than specifying new macros in the following way:

* a macro, once defined, is recognized in the user code and when found it is supposed to only modify a portion of the AST (generally rooted at the macro instance itself)
* a directive, when found, will usually leave the AST unchanged but it will change the compiler state in various ways, like:
  - it introduces a new symbol in the key symbol table (a macro does exactly this)
  - it introduces a new symbol in the var symbol table, for instance to declare "external" symbols
  - it loads a js file and interprets the directives stored in it (this would be  a "meta-module")

Another key difference is that directives are handled during the "combine" phase, and can introduce new symbols in the key symbol table (for instance, they can define macros).
Macros, on the other hand, are expanded _after_ the combine phase, and therefore cannot change the key symbol table.

The idea is to have a "compiler API", and allow the developer to specify new directives that will use the compiler API to perform operations like the ones described above.
A directive would be specified by the following:

* its key symbol (the one that triggers the directive)
* the type of its "main argument", if any
* the types of its "keyword arguments"
* the piece of code that implements the directive (to be executed when it is found in the code, similar to the "expand" code for macros)

The only built-in directive would be the "#directive" one, all the others can be implemented using it (also the "macro" directive!).
This would make the compiler simpler, and more modular.

In the beginning I thought that the compiler would need "compilation modes", like for generating a normal program, or a module, or a meta-module.
However now I think that the compiler should always generate the code it finds in the source, and it would be easier to have different "generation modes" using appropriate macros or directives that would "wrap" the whole file specifying what to generate.
For instance, a "#module" directive could define the "module" symbol so that the normal "module.exports" pattern can be used to produce a module.


## Macros that should be written

### The "unquote" macro already described in the readme.

### Looping macros

The idea is to base all looping constructs on macros that contain a loop and some _yield_ expression, and a _foreach_ macro that expands the loop inserting code at the yiend points.
There is a prototype of this but it is incomplete because it can only handle a single yield. In the more general case it would probably be appropriate to create a function that wraps the code to be inserted, and that will be called (instead of inlined) at every yield point.

### Macros to handle "containers"

I should write a _keysOf_ macro that expands into a "for ... in" but is integbrated in the "foreach" system using yield.
Moreover, since Javascript does not allow "subclassing" arrays, we should decide a sort of "protocol" to use any class as an array (like having a _length_ property but using ".at _index_" to get the element at index _index_).

Then we should integhrate all the usual methods into this "looping API", likely including the Underscore.js ones.

### Lazy looping and coroutines

Implement a "decompose to promises" of an arbitrary AST.
This would give Metascript both generators and coroutines (like core.async, but probably including try-catch which is something that normal generators don't handle).
